### Eclipse Workspace Patch 1.0
#P org.eclipse.jdt.ui
Index: ui/org/eclipse/jdt/internal/ui/workingsets/ConfigureWorkingSetAction.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/workingsets/ConfigureWorkingSetAction.java,v
retrieving revision 1.9
diff -u -r1.9 ConfigureWorkingSetAction.java
--- ui/org/eclipse/jdt/internal/ui/workingsets/ConfigureWorkingSetAction.java	18 Nov 2005 14:45:35 -0000	1.9
+++ ui/org/eclipse/jdt/internal/ui/workingsets/ConfigureWorkingSetAction.java	8 Dec 2005 20:19:30 -0000
@@ -14,6 +14,8 @@
 import java.util.Arrays;
 import java.util.List;
 
+import org.eclipse.swt.widgets.Shell;
+
 import org.eclipse.jface.action.Action;
 import org.eclipse.jface.dialogs.IDialogConstants;
 
@@ -21,13 +23,18 @@
 import org.eclipse.ui.IWorkingSet;
 
 public class ConfigureWorkingSetAction extends Action {
-
-	private final IWorkbenchPartSite fSite;
+ 
 	private WorkingSetModel fWorkingSetModel;
+	private Shell fShell; 
 
 	public ConfigureWorkingSetAction(IWorkbenchPartSite site) {
 		super(WorkingSetMessages.ConfigureWorkingSetAction_label); 
-		fSite= site;
+		fShell= site.getShell();
+	}
+	
+	public ConfigureWorkingSetAction(Shell shell) {
+		super(WorkingSetMessages.ConfigureWorkingSetAction_label); 
+		fShell= shell;
 	}
 	
 	public void setWorkingSetModel(WorkingSetModel model) {
@@ -39,9 +46,10 @@
 	 */
 	public void run() {
 		List workingSets= new ArrayList(Arrays.asList(fWorkingSetModel.getAllWorkingSets()));
+
 		IWorkingSet[] activeWorkingSets= fWorkingSetModel.getActiveWorkingSets();
 		WorkingSetConfigurationDialog dialog= new WorkingSetConfigurationDialog(
-			fSite.getShell(), 
+			fShell, 
 			(IWorkingSet[])workingSets.toArray(new IWorkingSet[workingSets.size()]),
 			activeWorkingSets); 
 		dialog.setSelection(activeWorkingSets);
Index: ui/org/eclipse/jdt/internal/ui/workingsets/ViewActionGroup.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/workingsets/ViewActionGroup.java,v
retrieving revision 1.8
diff -u -r1.8 ViewActionGroup.java
--- ui/org/eclipse/jdt/internal/ui/workingsets/ViewActionGroup.java	13 Apr 2005 17:35:11 -0000	1.8
+++ ui/org/eclipse/jdt/internal/ui/workingsets/ViewActionGroup.java	8 Dec 2005 20:19:30 -0000
@@ -45,7 +45,12 @@
 
 	public ViewActionGroup(int mode, IPropertyChangeListener changeListener, IWorkbenchPartSite site) {
 		fChangeListener= changeListener;
-		fFilterActionGroup= new WorkingSetFilterActionGroup(site, changeListener);
+		if(fChangeListener == null) {
+			fChangeListener = new IPropertyChangeListener() {
+				public void propertyChange(PropertyChangeEvent event) {}
+			};
+		}
+		fFilterActionGroup= new WorkingSetFilterActionGroup(site, fChangeListener);
 		fShowActionGroup= new WorkingSetShowActionGroup(site);
 		fMode= mode;
 		if (showWorkingSets())
@@ -70,16 +75,24 @@
 	 */
 	public void fillActionBars(IActionBars actionBars) {
 		super.fillActionBars(actionBars);
-		fMenuManager= actionBars.getMenuManager();
-		IMenuManager showMenu= new MenuManager(WorkingSetMessages.ViewActionGroup_show_label); 
-		fillShowMenu(showMenu);
-		fMenuManager.add(showMenu);
-		fMenuManager.add(new Separator(IWorkingSetActionGroup.ACTION_GROUP));
+		if(fMenuManager == null) {
+			fMenuManager= actionBars.getMenuManager();
+			fillViewMenu(fMenuManager);
+		}
+
 		if (fActiveActionGroup == null)
 			fActiveActionGroup= fFilterActionGroup;
 		((ActionGroup)fActiveActionGroup).fillActionBars(actionBars);
 	}
 	
+	private void fillViewMenu(IMenuManager menu) { 
+		
+		IMenuManager showMenu= new MenuManager(WorkingSetMessages.ViewActionGroup_show_label); 
+		fillShowMenu(showMenu);
+		menu.add(showMenu);
+		menu.add(new Separator(IWorkingSetActionGroup.ACTION_GROUP));
+	}
+	
 	private void fillShowMenu(IMenuManager menu) {
 		ViewAction projects= new ViewAction(this, SHOW_PROJECTS);
 		projects.setText(WorkingSetMessages.ViewActionGroup_projects_label); 
@@ -116,7 +129,8 @@
 		}
 		fActiveActionGroup.fillViewMenu(fMenuManager);
 		fMenuManager.updateAll(true);
-		fChangeListener.propertyChange(event);
+		if(fChangeListener != null)
+			fChangeListener.propertyChange(event);
 	}
 	
 	public WorkingSetFilterActionGroup getFilterGroup() {
Index: ui/org/eclipse/jdt/internal/ui/workingsets/WorkingSetModel.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/workingsets/WorkingSetModel.java,v
retrieving revision 1.13
diff -u -r1.13 WorkingSetModel.java
--- ui/org/eclipse/jdt/internal/ui/workingsets/WorkingSetModel.java	28 Oct 2005 20:59:06 -0000	1.13
+++ ui/org/eclipse/jdt/internal/ui/workingsets/WorkingSetModel.java	8 Dec 2005 20:19:30 -0000
@@ -1,13 +1,11 @@
-/*******************************************************************************
- * Copyright (c) 2000, 2005 IBM Corporation and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
+/***************************************************************************************************
+ * Copyright (c) 2000, 2005 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
 package org.eclipse.jdt.internal.ui.workingsets;
 
 import java.util.ArrayList;
@@ -36,12 +34,12 @@
 import org.eclipse.ui.PlatformUI;
 
 public class WorkingSetModel {
-	
+
 	public static final String CHANGE_WORKING_SET_MODEL_CONTENT= "workingSetModelChanged"; //$NON-NLS-1$
-	
+
 	public static final IElementComparer COMPARER= new WorkingSetComparar();
-	
-	private static final String TAG_LOCAL_WORKING_SET_MANAGER= "localWorkingSetManager"; //$NON-NLS-1$
+
+	public static final String TAG_LOCAL_WORKING_SET_MANAGER= "localWorkingSetManager"; //$NON-NLS-1$
 	private static final String TAG_ACTIVE_WORKING_SET= "activeWorkingSet"; //$NON-NLS-1$
 	private static final String TAG_WORKING_SET_NAME= "workingSetName"; //$NON-NLS-1$
 	private static final String TAG_CONFIGURED= "configured"; //$NON-NLS-1$
@@ -53,28 +51,29 @@
 	private OthersWorkingSetUpdater fOthersWorkingSetUpdater;
 
 	private ElementMapper fElementMapper= new ElementMapper();
-	
+
 	private boolean fConfigured;
 
 	private static class WorkingSetComparar implements IElementComparer {
 		public boolean equals(Object o1, Object o2) {
-			IWorkingSet w1= o1 instanceof IWorkingSet ? (IWorkingSet)o1 : null;
-			IWorkingSet w2= o2 instanceof IWorkingSet ? (IWorkingSet)o2 : null;
+			IWorkingSet w1= o1 instanceof IWorkingSet ? (IWorkingSet) o1 : null;
+			IWorkingSet w2= o2 instanceof IWorkingSet ? (IWorkingSet) o2 : null;
 			if (w1 == null || w2 == null)
 				return o1.equals(o2);
 			return w1 == w2;
 		}
+
 		public int hashCode(Object element) {
 			if (element instanceof IWorkingSet)
 				return System.identityHashCode(element);
 			return element.hashCode();
 		}
 	}
-	
+
 	private static class ElementMapper {
 		private Map fElementToWorkingSet= new HashMap();
 		private Map fWorkingSetToElement= new IdentityHashMap();
-		
+
 		private Map fResourceToWorkingSet= new HashMap();
 
 		public void clear() {
@@ -82,14 +81,16 @@
 			fWorkingSetToElement.clear();
 			fResourceToWorkingSet.clear();
 		}
+
 		public void rebuild(IWorkingSet[] workingSets) {
 			clear();
 			for (int i= 0; i < workingSets.length; i++) {
 				put(workingSets[i]);
 			}
 		}
+
 		public IAdaptable[] remove(IWorkingSet ws) {
-			IAdaptable[] elements= (IAdaptable[])fWorkingSetToElement.remove(ws);
+			IAdaptable[] elements= (IAdaptable[]) fWorkingSetToElement.remove(ws);
 			if (elements != null) {
 				for (int i= 0; i < elements.length; i++) {
 					removeElement(elements[i], ws);
@@ -97,8 +98,9 @@
 			}
 			return elements;
 		}
+
 		public IAdaptable[] refresh(IWorkingSet ws) {
-			IAdaptable[] oldElements= (IAdaptable[])fWorkingSetToElement.get(ws);
+			IAdaptable[] oldElements= (IAdaptable[]) fWorkingSetToElement.get(ws);
 			if (oldElements == null)
 				return null;
 			IAdaptable[] newElements= ws.getElements();
@@ -106,15 +108,16 @@
 			List toAdd= new ArrayList(Arrays.asList(newElements));
 			computeDelta(toRemove, toAdd, oldElements, newElements);
 			for (Iterator iter= toAdd.iterator(); iter.hasNext();) {
-				addElement((IAdaptable)iter.next(), ws);
+				addElement((IAdaptable) iter.next(), ws);
 			}
 			for (Iterator iter= toRemove.iterator(); iter.hasNext();) {
-				removeElement((IAdaptable)iter.next(), ws);
+				removeElement((IAdaptable) iter.next(), ws);
 			}
 			if (toRemove.size() > 0 || toAdd.size() > 0)
 				fWorkingSetToElement.put(ws, newElements);
 			return oldElements;
 		}
+
 		private void computeDelta(List toRemove, List toAdd, IAdaptable[] oldElements, IAdaptable[] newElements) {
 			for (int i= 0; i < oldElements.length; i++) {
 				toAdd.remove(oldElements[i]);
@@ -122,20 +125,25 @@
 			for (int i= 0; i < newElements.length; i++) {
 				toRemove.remove(newElements[i]);
 			}
-			
+
 		}
+
 		public IWorkingSet getFirstWorkingSet(Object element) {
-			return (IWorkingSet)getFirstElement(fElementToWorkingSet, element);
+			return (IWorkingSet) getFirstElement(fElementToWorkingSet, element);
 		}
+
 		public List getAllWorkingSets(Object element) {
 			return getAllElements(fElementToWorkingSet, element);
 		}
+
 		public IWorkingSet getFirstWorkingSetForResource(IResource resource) {
-			return (IWorkingSet)getFirstElement(fResourceToWorkingSet, resource);
+			return (IWorkingSet) getFirstElement(fResourceToWorkingSet, resource);
 		}
+
 		public List getAllWorkingSetsForResource(IResource resource) {
 			return getAllElements(fResourceToWorkingSet, resource);
 		}
+
 		private void put(IWorkingSet ws) {
 			if (fWorkingSetToElement.containsKey(ws))
 				return;
@@ -145,20 +153,23 @@
 				addElement(elements[i], ws);
 			}
 		}
+
 		private void addElement(IAdaptable element, IWorkingSet ws) {
 			addToMap(fElementToWorkingSet, element, ws);
-			IResource resource= (IResource)element.getAdapter(IResource.class);
+			IResource resource= (IResource) element.getAdapter(IResource.class);
 			if (resource != null) {
 				addToMap(fResourceToWorkingSet, resource, ws);
 			}
 		}
+
 		private void removeElement(IAdaptable element, IWorkingSet ws) {
 			removeFromMap(fElementToWorkingSet, element, ws);
-			IResource resource= (IResource)element.getAdapter(IResource.class);
+			IResource resource= (IResource) element.getAdapter(IResource.class);
 			if (resource != null) {
 				removeFromMap(fResourceToWorkingSet, resource, ws);
 			}
 		}
+
 		private void addToMap(Map map, IAdaptable key, IWorkingSet value) {
 			Object obj= map.get(key);
 			if (obj == null) {
@@ -169,21 +180,22 @@
 				l.add(value);
 				map.put(key, l);
 			} else if (obj instanceof List) {
-				((List)obj).add(value);
+				((List) obj).add(value);
 			}
 		}
+
 		private void removeFromMap(Map map, IAdaptable key, IWorkingSet value) {
 			Object current= map.get(key);
 			if (current == null) {
 				return;
 			} else if (current instanceof List) {
-				List list= (List)current;
+				List list= (List) current;
 				list.remove(value);
 				switch (list.size()) {
-					case 0:
+					case 0 :
 						map.remove(key);
 						break;
-					case 1:
+					case 1 :
 						map.put(key, list.get(0));
 						break;
 				}
@@ -191,16 +203,18 @@
 				map.remove(key);
 			}
 		}
+
 		private Object getFirstElement(Map map, Object key) {
 			Object obj= map.get(key);
-			if (obj instanceof List) 
-				return ((List)obj).get(0);
+			if (obj instanceof List)
+				return ((List) obj).get(0);
 			return obj;
 		}
+
 		private List getAllElements(Map map, Object key) {
 			Object obj= map.get(key);
 			if (obj instanceof List)
-				return (List)obj;
+				return (List) obj;
 			if (obj == null)
 				return Collections.EMPTY_LIST;
 			List result= new ArrayList(1);
@@ -208,27 +222,27 @@
 			return result;
 		}
 	}
-	
+
 	public WorkingSetModel() {
 		fLocalWorkingSetManager= PlatformUI.getWorkbench().createLocalWorkingSetManager();
 		addListenersToWorkingSetManagers();
-    	fActiveWorkingSets= new ArrayList(2);
-    	
-    	IWorkingSet others= fLocalWorkingSetManager.createWorkingSet(WorkingSetMessages.WorkingSetModel_others_name, new IAdaptable[0]); 
-    	others.setId(OthersWorkingSetUpdater.ID);
-    	fLocalWorkingSetManager.addWorkingSet(others);
-    	fActiveWorkingSets.add(others);
-    	
-    	fOthersWorkingSetUpdater.init(this);
-    	fElementMapper.rebuild(getActiveWorkingSets());
+		fActiveWorkingSets= new ArrayList(2);
+
+		IWorkingSet others= fLocalWorkingSetManager.createWorkingSet(WorkingSetMessages.WorkingSetModel_others_name, new IAdaptable[0]);
+		others.setId(OthersWorkingSetUpdater.ID);
+		fLocalWorkingSetManager.addWorkingSet(others);
+		fActiveWorkingSets.add(others);
+
+		fOthersWorkingSetUpdater.init(this);
+		fElementMapper.rebuild(getActiveWorkingSets());
 	}
-	
+
 	public WorkingSetModel(IMemento memento) {
 		restoreState(memento);
 		fOthersWorkingSetUpdater.init(this);
-    	fElementMapper.rebuild(getActiveWorkingSets());
+		fElementMapper.rebuild(getActiveWorkingSets());
 	}
-	
+
 	private void addListenersToWorkingSetManagers() {
 		fListeners= new ListenerList();
 		fWorkingSetManagerListener= new IPropertyChangeListener() {
@@ -239,7 +253,7 @@
 		PlatformUI.getWorkbench().getWorkingSetManager().addPropertyChangeListener(fWorkingSetManagerListener);
 		fLocalWorkingSetManager.addPropertyChangeListener(fWorkingSetManagerListener);
 	}
-	
+
 	public void dispose() {
 		if (fWorkingSetManagerListener != null) {
 			PlatformUI.getWorkbench().getWorkingSetManager().removePropertyChangeListener(fWorkingSetManagerListener);
@@ -248,118 +262,119 @@
 			fWorkingSetManagerListener= null;
 		}
 	}
-	
-	//---- model relationships ---------------------------------------
-	
+
+	// ---- model relationships ---------------------------------------
+
     public IAdaptable[] getChildren(IWorkingSet workingSet) {
-    	return workingSet.getElements();
-    }
-    
-    public Object getParent(Object element) {
-    	if (element instanceof IWorkingSet && fActiveWorkingSets.contains(element))
-    		return this;
-    	return fElementMapper.getFirstWorkingSet(element);
-    }
-    
-    public Object[] getAllParents(Object element) {
-    	if (element instanceof IWorkingSet && fActiveWorkingSets.contains(element))
-    		return new Object[] {this};
-    	return fElementMapper.getAllWorkingSets(element).toArray();
-    }
-    
-    public Object[] addWorkingSets(Object[] elements) {
-    	List result= null;
-    	for (int i= 0; i < elements.length; i++) {
-    		Object element= elements[i];
-    		List sets= null;
+		return workingSet.getElements();
+	}
+
+	public Object getParent(Object element) {
+		if (element instanceof IWorkingSet && fActiveWorkingSets.contains(element))
+			return this;
+		return fElementMapper.getFirstWorkingSet(element);
+	}
+
+	public Object[] getAllParents(Object element) {
+		if (element instanceof IWorkingSet && fActiveWorkingSets.contains(element))
+			return new Object[]{this};
+		return fElementMapper.getAllWorkingSets(element).toArray();
+	}
+
+	public Object[] addWorkingSets(Object[] elements) {
+		List result= null;
+		for (int i= 0; i < elements.length; i++) {
+			Object element= elements[i];
+			List sets= null;
 			if (element instanceof IResource) {
-    			sets= fElementMapper.getAllWorkingSetsForResource((IResource)element);
-    		} else {
-    			sets= fElementMapper.getAllWorkingSets(element);
-    		}
+				sets= fElementMapper.getAllWorkingSetsForResource((IResource) element);
+			} else {
+				sets= fElementMapper.getAllWorkingSets(element);
+			}
 			if (sets != null && sets.size() > 0) {
 				if (result == null)
 					result= new ArrayList(Arrays.asList(elements));
 				result.addAll(sets);
 			}
 		}
-    	if (result == null)
-    		return elements;
-    	return result.toArray();
-    }
-    
-    public boolean needsConfiguration() {
-    	return !fConfigured && fActiveWorkingSets.size() == 1 &&
-			OthersWorkingSetUpdater.ID.equals(((IWorkingSet)fActiveWorkingSets.get(0)).getId());
-    }
-    
-    public void configured() {
-    	fConfigured= true;
-    }
-    
-    //---- working set management -----------------------------------
-    
+		if (result == null)
+			return elements;
+		return result.toArray();
+	}
+
+	public boolean needsConfiguration() {
+		return !fConfigured && fActiveWorkingSets.size() == 1 && OthersWorkingSetUpdater.ID.equals(((IWorkingSet) fActiveWorkingSets.get(0)).getId());
+	}
+
+	public void configured() {
+		fConfigured= true;
+	}
+
+	// ---- working set management -----------------------------------
+
 	/**
-     * Adds a property change listener.
-     * 
-     * @param listener the property change listener to add
-     */
-    public void addPropertyChangeListener(IPropertyChangeListener listener) {
-    	fListeners.add(listener);
-    }
-    
-    /**
-     * Removes the property change listener.
-     * 
-     * @param listener the property change listener to remove
-     */
-    public void removePropertyChangeListener(IPropertyChangeListener listener) {
-    	fListeners.remove(listener);
-    }
-    
-    public IWorkingSet[] getActiveWorkingSets() {
-    	return (IWorkingSet[])fActiveWorkingSets.toArray(new IWorkingSet[fActiveWorkingSets.size()]);
-    }
-    
-    public IWorkingSet[] getAllWorkingSets() {
-    	List result= new ArrayList();
-    	result.addAll(fActiveWorkingSets);
-    	IWorkingSet[] locals= fLocalWorkingSetManager.getWorkingSets();
-    	for (int i= 0; i < locals.length; i++) {
+	 * Adds a property change listener.
+	 * 
+	 * @param listener
+	 *            the property change listener to add
+	 */
+	public void addPropertyChangeListener(IPropertyChangeListener listener) {
+		fListeners.add(listener);
+	}
+
+	/**
+	 * Removes the property change listener.
+	 * 
+	 * @param listener
+	 *            the property change listener to remove
+	 */
+	public void removePropertyChangeListener(IPropertyChangeListener listener) {
+		fListeners.remove(listener);
+	}
+
+	public IWorkingSet[] getActiveWorkingSets() {
+		return (IWorkingSet[]) fActiveWorkingSets.toArray(new IWorkingSet[fActiveWorkingSets.size()]);
+	}
+
+	public IWorkingSet[] getAllWorkingSets() {
+		List result= new ArrayList();
+		result.addAll(fActiveWorkingSets);
+		IWorkingSet[] locals= fLocalWorkingSetManager.getWorkingSets();
+		for (int i= 0; i < locals.length; i++) {
 			if (!result.contains(locals[i]))
 				result.add(locals[i]);
 		}
-    	IWorkingSet[] globals= PlatformUI.getWorkbench().getWorkingSetManager().getWorkingSets();
-    	for (int i= 0; i < globals.length; i++) {
+		IWorkingSet[] globals= PlatformUI.getWorkbench().getWorkingSetManager().getWorkingSets();
+		for (int i= 0; i < globals.length; i++) {
 			if (!result.contains(globals[i]))
 				result.add(globals[i]);
 		}
-    	return (IWorkingSet[])result.toArray(new IWorkingSet[result.size()]);
-    }
-    
-    public void setActiveWorkingSets(IWorkingSet[] workingSets) {
-    	fActiveWorkingSets= new ArrayList(Arrays.asList(workingSets));
-    	fElementMapper.rebuild(getActiveWorkingSets());
-    	fOthersWorkingSetUpdater.updateElements();
-    	fireEvent(new PropertyChangeEvent(this, CHANGE_WORKING_SET_MODEL_CONTENT, null, null));
-    }
-	
+		return (IWorkingSet[]) result.toArray(new IWorkingSet[result.size()]);
+	}
+
+	public void setActiveWorkingSets(IWorkingSet[] workingSets) {
+		fActiveWorkingSets= new ArrayList(Arrays.asList(workingSets));
+		fElementMapper.rebuild(getActiveWorkingSets());
+		fOthersWorkingSetUpdater.updateElements();
+		fireEvent(new PropertyChangeEvent(this, CHANGE_WORKING_SET_MODEL_CONTENT, null, null));
+	}
+
 	public void saveState(IMemento memento) {
 		memento.putString(TAG_CONFIGURED, Boolean.toString(fConfigured));
 		fLocalWorkingSetManager.saveState(memento.createChild(TAG_LOCAL_WORKING_SET_MANAGER));
 		for (Iterator iter= fActiveWorkingSets.iterator(); iter.hasNext();) {
 			IMemento active= memento.createChild(TAG_ACTIVE_WORKING_SET);
-			IWorkingSet workingSet= (IWorkingSet)iter.next();
+			IWorkingSet workingSet= (IWorkingSet) iter.next();
 			active.putString(TAG_WORKING_SET_NAME, workingSet.getName());
 		}
 	}
-	
+
 	private void restoreState(IMemento memento) {
 		String configured= memento.getString(TAG_CONFIGURED);
 		if (configured != null)
 			fConfigured= Boolean.valueOf(configured).booleanValue();
 		fLocalWorkingSetManager= PlatformUI.getWorkbench().createLocalWorkingSetManager();
-		addListenersToWorkingSetManagers();
+		addListenersToWorkingSetManagers(); 
 		fLocalWorkingSetManager.restoreState(memento.getChild(TAG_LOCAL_WORKING_SET_MANAGER));
 		IWorkingSet history= getHistoryWorkingSet();
 		if (history != null) {
@@ -380,54 +395,54 @@
 			}
 		}
 	}
-    private void workingSetManagerChanged(PropertyChangeEvent event) {
+
+	private void workingSetManagerChanged(PropertyChangeEvent event) {
 		String property= event.getProperty();
-    	if (IWorkingSetManager.CHANGE_WORKING_SET_UPDATER_INSTALLED.equals(property) && event.getSource() == fLocalWorkingSetManager) {
-			IWorkingSetUpdater updater= (IWorkingSetUpdater)event.getNewValue();
+		if (IWorkingSetManager.CHANGE_WORKING_SET_UPDATER_INSTALLED.equals(property) && event.getSource() == fLocalWorkingSetManager) {
+			IWorkingSetUpdater updater= (IWorkingSetUpdater) event.getNewValue();
 			if (updater instanceof OthersWorkingSetUpdater) {
-				fOthersWorkingSetUpdater= (OthersWorkingSetUpdater)updater;
+				fOthersWorkingSetUpdater= (OthersWorkingSetUpdater) updater;
 			}
 			return;
 		}
-    	// don't handle working sets not managed by the model
-    	if (!isAffected(event))
-    		return;
-    	
+		// don't handle working sets not managed by the model
+		if (!isAffected(event))
+			return;
+
 		if (IWorkingSetManager.CHANGE_WORKING_SET_CONTENT_CHANGE.equals(property)) {
-			IWorkingSet workingSet= (IWorkingSet)event.getNewValue();
+			IWorkingSet workingSet= (IWorkingSet) event.getNewValue();
 			IAdaptable[] elements= fElementMapper.refresh(workingSet);
 			if (elements != null) {
 				fireEvent(event);
 			}
 		} else if (IWorkingSetManager.CHANGE_WORKING_SET_REMOVE.equals(property)) {
-			IWorkingSet workingSet= (IWorkingSet)event.getOldValue();
+			IWorkingSet workingSet= (IWorkingSet) event.getOldValue();
 			List elements= new ArrayList(fActiveWorkingSets);
 			elements.remove(workingSet);
-			setActiveWorkingSets((IWorkingSet[])elements.toArray(new IWorkingSet[elements.size()]));
-    	} else if (IWorkingSetManager.CHANGE_WORKING_SET_NAME_CHANGE.equals(property)) {
+			setActiveWorkingSets((IWorkingSet[]) elements.toArray(new IWorkingSet[elements.size()]));
+		} else if (IWorkingSetManager.CHANGE_WORKING_SET_NAME_CHANGE.equals(property)) {
 			fireEvent(event);
 		}
 	}
-    
-    private void fireEvent(PropertyChangeEvent event) {
-    	Object[] listeners= fListeners.getListeners();
-    	for (int i= 0; i < listeners.length; i++) {
-			((IPropertyChangeListener)listeners[i]).propertyChange(event);
-		}
-    }
-    
-    private boolean isAffected(PropertyChangeEvent event) {
-    	if (fActiveWorkingSets == null)
-    		return false;
-    	Object oldValue= event.getOldValue();
-    	Object newValue= event.getNewValue();
-    	if ((oldValue != null && fActiveWorkingSets.contains(oldValue)) 
-    		|| (newValue != null && fActiveWorkingSets.contains(newValue))) {
-    		return true;
-    	}
-    	return false;
-    }
-	
+
+	private void fireEvent(PropertyChangeEvent event) {
+		Object[] listeners= fListeners.getListeners();
+		for (int i= 0; i < listeners.length; i++) {
+			((IPropertyChangeListener) listeners[i]).propertyChange(event);
+		}
+	}
+
+	private boolean isAffected(PropertyChangeEvent event) {
+		if (fActiveWorkingSets == null)
+			return false;
+		Object oldValue= event.getOldValue();
+		Object newValue= event.getNewValue();
+		if ((oldValue != null && fActiveWorkingSets.contains(oldValue)) || (newValue != null && fActiveWorkingSets.contains(newValue))) {
+			return true;
+		}
+		return false;
+	}
+
 	private IWorkingSet getHistoryWorkingSet() {
 		IWorkingSet[] workingSets= fLocalWorkingSetManager.getWorkingSets();
 		for (int i= 0; i < workingSets.length; i++) {
Index: ui/org/eclipse/jdt/ui/StandardJavaElementContentProvider.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/ui/StandardJavaElementContentProvider.java,v
retrieving revision 1.27
diff -u -r1.27 StandardJavaElementContentProvider.java
--- ui/org/eclipse/jdt/ui/StandardJavaElementContentProvider.java	17 Jun 2005 15:51:56 -0000	1.27
+++ ui/org/eclipse/jdt/ui/StandardJavaElementContentProvider.java	8 Dec 2005 20:19:30 -0000
@@ -13,16 +13,28 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.eclipse.core.runtime.CoreException;
+
 import org.eclipse.core.resources.IFile;
 import org.eclipse.core.resources.IFolder;
 import org.eclipse.core.resources.IProject;
 import org.eclipse.core.resources.IResource;
-import org.eclipse.core.runtime.CoreException;
 
 import org.eclipse.jface.viewers.ITreeContentProvider;
 import org.eclipse.jface.viewers.Viewer;
 
-import org.eclipse.jdt.core.*;
+import org.eclipse.jdt.core.IClassFile;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaElementDelta;
+import org.eclipse.jdt.core.IJavaModel;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.IParent;
+import org.eclipse.jdt.core.ISourceReference;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
  
 /**
  * A base content provider for Java elements. It provides access to the
@@ -51,11 +63,15 @@
  * 
  * @since 2.0
  */
-public class StandardJavaElementContentProvider implements ITreeContentProvider, IWorkingCopyProvider {
+public class StandardJavaElementContentProvider implements ITreeContentProvider, IWorkingCopyProvider {	
+
+	public static final int SHOW_MEMBERS= 1<<1;
+	public static final int SHOW_RESOURCES= 1<<2;
 
 	protected static final Object[] NO_CHILDREN= new Object[0];
 	protected boolean fProvideMembers;
 	protected boolean fProvideWorkingCopy;
+	protected boolean fIncludeResources;
 	
 	/**
 	 * Creates a new content provider. The content provider does not
@@ -81,9 +97,22 @@
 	 * @param provideMembers if <code>true</code> members below compilation units 
 	 * and class files are provided. 
 	 */
-	public StandardJavaElementContentProvider(boolean provideMembers) {
-		fProvideMembers= provideMembers;
-		fProvideWorkingCopy= provideMembers;
+	public StandardJavaElementContentProvider(boolean provideMembers) { 
+		this( (provideMembers ? SHOW_MEMBERS : 0) | SHOW_RESOURCES);
+	}
+	
+	
+	
+	/**
+	 * Creates a new <code>StandardJavaElementContentProvider</code>.
+	 *
+	 * @param provideMembers if <code>true</code> members below compilation units 
+	 * and class files are provided. 
+	 */
+	public StandardJavaElementContentProvider(int options) {
+		fProvideMembers= (options & SHOW_MEMBERS) != 0;
+		fIncludeResources =  (options & SHOW_RESOURCES) != 0;
+		fProvideWorkingCopy= fProvideMembers;
 	}
 	
 	/**
@@ -155,7 +184,7 @@
 	/* (non-Javadoc)
 	 * Method declared on ITreeContentProvider.
 	 */
-	public Object[] getChildren(Object element) {
+	public Object[] getChildren(Object element) { 
 		if (!exists(element))
 			return NO_CHILDREN;
 			
@@ -172,8 +201,10 @@
 			if (element instanceof IPackageFragment) 
 				return getPackageContents((IPackageFragment)element);
 				
-			if (element instanceof IFolder)
-				return getResources((IFolder)element);
+			if (element instanceof IFolder) {
+				return (fIncludeResources) ?  getResources((IFolder)element) : NO_CHILDREN;
+				
+			}
 			
 			if (getProvideMembers() && element instanceof ISourceReference && element instanceof IParent) {
 				return ((IParent)element).getChildren();
@@ -233,12 +264,15 @@
 	
 	private Object[] getPackageFragments(IPackageFragmentRoot root) throws JavaModelException {
 		IJavaElement[] fragments= root.getChildren();
-		Object[] nonJavaResources= root.getNonJavaResources();
-		if (nonJavaResources == null)
+		if(fIncludeResources) {
+			Object[] nonJavaResources= root.getNonJavaResources();
+			if (nonJavaResources == null)
+				return fragments;
+			return concatenate(fragments, nonJavaResources);
+		} else 
 			return fragments;
-		return concatenate(fragments, nonJavaResources);
-	}
-	
+	}	
+
 	/**
 	 * Note: This method is for internal use only. Clients should not call this method.
 	 */
@@ -261,7 +295,7 @@
 				list.add(root);
 			} 
 		}
-		return concatenate(list.toArray(), project.getNonJavaResources());
+		return (fIncludeResources) ? concatenate(list.toArray(), project.getNonJavaResources()) : list.toArray();
 	}
 
 	/**
Index: ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerContentProvider.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerContentProvider.java,v
retrieving revision 1.49
diff -u -r1.49 PackageExplorerContentProvider.java
--- ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerContentProvider.java	10 Aug 2005 10:53:37 -0000	1.49
+++ ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerContentProvider.java	8 Dec 2005 20:19:30 -0000
@@ -84,7 +84,22 @@
 		super(provideMembers);	
 		fPart= part;
 	}
+
 	
+	/**
+	 * Creates a new content provider for Java elements.
+	 */
+	public PackageExplorerContentProvider(boolean provideMembers) {
+		super(provideMembers);	 
+	}
+	
+	/**
+	 * Creates a new content provider for Java elements.
+	 */
+	public PackageExplorerContentProvider(int options) {
+		super(options);	 
+	}
+		
 	/* package */ PackageFragmentProvider getPackageFragmentProvider() {
 		return fPackageFragmentProvider;
 	}
@@ -136,8 +151,9 @@
 		int type= -1;
 		if (element instanceof IJavaElement)
 			type= ((IJavaElement)element).getElementType();
-		return (!fIsFlatLayout && (type == IJavaElement.PACKAGE_FRAGMENT || type == IJavaElement.PACKAGE_FRAGMENT_ROOT || type == IJavaElement.JAVA_PROJECT));
+		return (fIsFlatLayout && (type == IJavaElement.PACKAGE_FRAGMENT || type == IJavaElement.PACKAGE_FRAGMENT_ROOT || type == IJavaElement.JAVA_PROJECT));
 	}		
+	
 
 	public Object[] getChildren(Object parentElement) {
 		Object[] children= NO_CHILDREN;
@@ -148,12 +164,16 @@
 			if (parentElement instanceof ClassPathContainer)
 				return getContainerPackageFragmentRoots((ClassPathContainer)parentElement);
 				
-			if (parentElement instanceof IProject) 
-				return ((IProject)parentElement).members();
+			if (parentElement instanceof IProject) {
+				if(fIncludeResources) 
+					return ((IProject)parentElement).members();
+				else
+					return NO_CHILDREN;
+			}
 					
 			if (needsToDelegateGetChildren(parentElement)) {
-				Object[] packageFragments= fPackageFragmentProvider.getChildren(parentElement);
-				children= getWithParentsResources(packageFragments, parentElement);
+				Object[] packageFragments= fPackageFragmentProvider.getChildren(parentElement);			
+				children= getWithParentsResources(packageFragments, parentElement); 
 			} else {
 				children= super.getChildren(parentElement);
 			}
@@ -169,6 +189,7 @@
 			return NO_CHILDREN;
 		}
 	}
+ 
 
 	private Object[] rootsAndContainers(IJavaProject project, Object[] roots) throws JavaModelException { 
 		List result= new ArrayList(roots.length);
@@ -246,7 +267,7 @@
 		int type= -1;
 		if (element instanceof IJavaElement)
 			type= ((IJavaElement)element).getElementType();
-		return (!fIsFlatLayout && type == IJavaElement.PACKAGE_FRAGMENT);
+		return (fIsFlatLayout && type == IJavaElement.PACKAGE_FRAGMENT);
 	}		
 
 	/**
@@ -303,7 +324,7 @@
 				return;	
 		}
 		
-		if (!fIsFlatLayout && elementType == IJavaElement.PACKAGE_FRAGMENT) {
+		if (fIsFlatLayout && elementType == IJavaElement.PACKAGE_FRAGMENT) {
 			fPackageFragmentProvider.processDelta(delta);
 			if (processResourceDeltas(delta.getResourceDeltas(), element))
 			    return;
@@ -560,6 +581,10 @@
 	public void setIsFlatLayout(boolean state) {
 		fIsFlatLayout= state;
 	}
+	
+	protected final boolean isFlatLayout() {
+		return fIsFlatLayout;
+	}
 	/**
 	 * Process resource deltas.
 	 *
Index: ui/org/eclipse/jdt/internal/ui/packageview/WorkingSetAwareContentProvider.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/packageview/WorkingSetAwareContentProvider.java,v
retrieving revision 1.10
diff -u -r1.10 WorkingSetAwareContentProvider.java
--- ui/org/eclipse/jdt/internal/ui/packageview/WorkingSetAwareContentProvider.java	28 Oct 2005 20:59:06 -0000	1.10
+++ ui/org/eclipse/jdt/internal/ui/packageview/WorkingSetAwareContentProvider.java	8 Dec 2005 20:19:30 -0000
@@ -54,6 +54,17 @@
 		fWorkingSetModel.addPropertyChangeListener(fListener);
 	}
 	
+	public WorkingSetAwareContentProvider(boolean provideMembers, WorkingSetModel model) {
+		super(provideMembers);
+		fWorkingSetModel= model;
+		fListener= new IPropertyChangeListener() {
+					public void propertyChange(PropertyChangeEvent event) {
+						workingSetModelChanged(event);
+					}
+				};
+		fWorkingSetModel.addPropertyChangeListener(fListener);
+	}
+	
 	/**
 	 * {@inheritDoc}
 	 */
Index: META-INF/MANIFEST.MF
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/META-INF/MANIFEST.MF,v
retrieving revision 1.12
diff -u -r1.12 MANIFEST.MF
--- META-INF/MANIFEST.MF	25 Nov 2005 10:26:31 -0000	1.12
+++ META-INF/MANIFEST.MF	8 Dec 2005 20:19:29 -0000
@@ -99,8 +99,7 @@
  org.eclipse.jdt.ui.text.java,
  org.eclipse.jdt.ui.text.java.hover,
  org.eclipse.jdt.ui.wizards
-Require-Bundle: 
- org.eclipse.ui,
+Require-Bundle: org.eclipse.ui,
  org.eclipse.ui.console,
  org.eclipse.help,
  org.eclipse.core.expressions,
@@ -121,6 +120,7 @@
  org.eclipse.core.runtime.compatibility,
  org.eclipse.ltk.core.refactoring,
  org.eclipse.ltk.ui.refactoring,
- org.eclipse.ui.forms
-Eclipse-LazyStart: true
+ org.eclipse.ui.forms,
+ org.eclipse.ui.navigator
+Eclipse-LazyStart: true 
 Plugin-Class: org.eclipse.jdt.internal.ui.JavaPlugin
Index: plugin.xml
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/plugin.xml,v
retrieving revision 1.577
diff -u -r1.577 plugin.xml
--- plugin.xml	25 Nov 2005 11:21:01 -0000	1.577
+++ plugin.xml	8 Dec 2005 20:19:29 -0000
@@ -4677,4 +4677,62 @@
             streamMergerId="org.eclipse.jdt.ui.refactoring.model.JavaFileStreamMerger"/>
    </extension>
 
+
+    <!-- ADDITIONS BELOW THIS LINE -->
+      
+    <extension
+          point="org.eclipse.ui.navigator.viewer">
+       <viewerContentBinding 
+             viewerId="org.eclipse.ui.navigator.resourceContent">
+          <includes>
+       	      <contentExtension pattern="org.eclipse.jdt.java.navigator" />       
+          </includes>       
+       </viewerContentBinding>
+    </extension> 
+      
+    <extension
+          point="org.eclipse.ui.navigator.navigatorContent">
+       <navigatorContent
+             contentProvider="org.eclipse.jdt.internal.ui.packageview.PreferenceAwareContentProvider"
+             id="org.eclipse.jdt.java.navigator"
+             labelProvider="org.eclipse.jdt.internal.ui.packageview.PreferenceAwareLabelProvider"
+             name="JDT Extension"
+             priority="high">
+          <enablement> 
+	         <or>           
+	               <adapt 
+	                     type="org.eclipse.core.resources.IProject" > 
+		                  <test
+		                     property="org.eclipse.ui.navigator.resources.projectNature"
+		                     value="org.eclipse.jdt.core.javanature" />
+	               </adapt>  
+	           <instanceof 
+	                 value="org.eclipse.jdt.core.IJavaProject" /> 
+	           <instanceof 
+	                 value="org.eclipse.jdt.core.IJavaElement" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.internal.core.JarEntryFile" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.core.IClassFile" /> 
+	           <instanceof
+	                 value="org.eclipse.jdt.internal.ui.packageview.ClassPathContainer" /> 
+	           <instanceof
+	                 value="org.eclipse.core.resources.IFolder" /> 
+	           <instanceof
+	                 value="org.eclipse.core.resources.IFile" /> 
+	           							<instanceof 
+	                 						value="org.eclipse.jdt.internal.ui.workingsets.WorkingSetModel" /> 
+	         </or>
+          </enablement>
+	          <actionProvider 
+	               class="org.eclipse.jdt.internal.ui.packageview.PackageExplorerActionProvider">
+	               <enablement>	               
+	               <adapt 
+	                     type="org.eclipse.jdt.core.IJavaElement" /> 
+	               </enablement>
+	          </actionProvider>
+          <duplicateContentFilter viewerFilter="org.eclipse.jdt.internal.ui.packageview.JavaResourceDuplicationFilter"/>
+       </navigatorContent>
+    </extension>
+     
 </plugin>
\ No newline at end of file
Index: ui/org/eclipse/jdt/internal/ui/actions/MultiActionGroup.java
===================================================================
RCS file: /home/eclipse/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/actions/MultiActionGroup.java,v
retrieving revision 1.7
diff -u -r1.7 MultiActionGroup.java
--- ui/org/eclipse/jdt/internal/ui/actions/MultiActionGroup.java	17 Jun 2005 15:51:51 -0000	1.7
+++ ui/org/eclipse/jdt/internal/ui/actions/MultiActionGroup.java	8 Dec 2005 20:19:30 -0000
@@ -37,6 +37,8 @@
  */
 public class MultiActionGroup extends ActionGroup {
 	
+	public IAction[] NO_ACTIONS = new IAction[0];
+	
 	private IAction[] fActions; 
 	
 	private int fCurrentSelection;
@@ -57,6 +59,28 @@
 		fCurrentSelection= currentSelection;
 		fActions= actions;
 	}
+	
+	/**
+	 * Creates a new action group with a given set of actions.
+	 * 
+	 * @param actions			the actions for this multi group
+	 * @param currentSelection	decides which action is selected in the menu on start up.
+	 * 							Denotes the location in the actions array of the current
+	 * 							selected state. It cannot be null.
+	 */
+	public MultiActionGroup(int currentSelection) {
+		super();
+		
+		fCurrentSelection= currentSelection;
+		fActions= NO_ACTIONS;
+	}
+	
+	protected final void setActions(IAction[] actions) {
+		if(actions != null)
+			fActions = actions;
+		else
+			fActions = NO_ACTIONS;
+	}
 
 	/**
 	 * Add the actions to the given menu manager.
Index: ui/org/eclipse/jdt/internal/ui/packageview/CommonLayoutActionGroup.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/CommonLayoutActionGroup.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/CommonLayoutActionGroup.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/CommonLayoutActionGroup.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,134 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2005 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.jface.viewers.StructuredViewer;
+
+import org.eclipse.ui.IActionBars;
+import org.eclipse.ui.IWorkbenchActionConstants;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+
+import org.eclipse.jdt.internal.ui.IJavaHelpContextIds;
+import org.eclipse.jdt.internal.ui.JavaPluginImages;
+import org.eclipse.jdt.internal.ui.actions.MultiActionGroup;
+import org.eclipse.jdt.internal.ui.packageview.IExtensionStateConstants.Values;
+
+/**
+ * Adds view menus to switch between flat and hierarchical layout.
+ * 
+ * @since 2.1
+ */
+public class CommonLayoutActionGroup extends MultiActionGroup {
+
+	private boolean fHasContributedToViewMenu = false;
+	private IAction fHierarchicalLayout = null;
+	private IAction fFlatLayoutAction = null;
+
+	private IExtensionStateModel fStateModel;
+
+	public CommonLayoutActionGroup(StructuredViewer aStructuredViewer, IExtensionStateModel aStateModel) {
+		super(aStateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT) ? 0 : 1);
+		IAction[] actions = createActions(aStructuredViewer, aStateModel);
+		setActions(actions);
+		fStateModel = aStateModel;
+	}
+
+	/* (non-Javadoc)
+	 * @see ActionGroup#fillActionBars(IActionBars)
+	 */
+	public void fillActionBars(IActionBars actionBars) {
+		super.fillActionBars(actionBars);
+		if(!fHasContributedToViewMenu) {
+			synchronized(this) {
+				if(!fHasContributedToViewMenu) {
+					fHasContributedToViewMenu = true;
+					contributeToViewMenu(actionBars.getMenuManager());
+				}
+			}
+		}
+	}
+	
+	private void contributeToViewMenu(IMenuManager viewMenu) {
+		viewMenu.add(new Separator());
+
+		// Create layout sub menu
+		
+		IMenuManager layoutSubMenu= new MenuManager(PackagesMessages.LayoutActionGroup_label); 
+		final String layoutGroupName= "layout"; //$NON-NLS-1$
+		Separator marker= new Separator(layoutGroupName);
+
+		viewMenu.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
+		viewMenu.add(marker);
+		viewMenu.appendToGroup(layoutGroupName, layoutSubMenu);
+		viewMenu.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS+"-end"));//$NON-NLS-1$		
+		addActions(layoutSubMenu);
+	}
+	
+	
+	private IAction[] createActions(StructuredViewer aStructuredViewer, IExtensionStateModel aStateModel) {
+		
+		fFlatLayoutAction= new CommonLayoutAction(aStructuredViewer, aStateModel, true);
+		fFlatLayoutAction.setText(PackagesMessages.LayoutActionGroup_flatLayoutAction_label); 
+		JavaPluginImages.setLocalImageDescriptors(fFlatLayoutAction, "flatLayout.gif"); //$NON-NLS-1$
+		
+		fHierarchicalLayout= new CommonLayoutAction(aStructuredViewer, aStateModel, false);
+		fHierarchicalLayout.setText(PackagesMessages.LayoutActionGroup_hierarchicalLayoutAction_label);	  
+		JavaPluginImages.setLocalImageDescriptors(fHierarchicalLayout, "hierarchicalLayout.gif"); //$NON-NLS-1$
+		
+		fHierarchicalLayout.setChecked(!aStateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT));
+		fFlatLayoutAction.setChecked(aStateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT));
+		
+		return new IAction[]{fFlatLayoutAction, fHierarchicalLayout};
+	}
+	
+	public void setFlatLayout(boolean flatLayout) {
+		fHierarchicalLayout.setChecked(!flatLayout);
+		fFlatLayoutAction.setChecked(flatLayout);
+	}
+	 
+}
+
+class CommonLayoutAction extends Action implements IAction {
+
+	private final boolean fIsFlatLayout;
+	private IExtensionStateModel fStateModel;
+	private StructuredViewer fStructuredViewer;
+
+	public CommonLayoutAction(StructuredViewer aStructuredViewer, IExtensionStateModel aStateModel, boolean flat) {
+		super("", AS_RADIO_BUTTON); //$NON-NLS-1$
+		fStateModel = aStateModel;
+		fStructuredViewer = aStructuredViewer;
+		fIsFlatLayout= flat; 
+		if (fIsFlatLayout)
+			PlatformUI.getWorkbench().getHelpSystem().setHelp(this, IJavaHelpContextIds.LAYOUT_FLAT_ACTION);
+		else
+			PlatformUI.getWorkbench().getHelpSystem().setHelp(this, IJavaHelpContextIds.LAYOUT_HIERARCHICAL_ACTION);
+	}
+
+	/*
+	 * @see org.eclipse.jface.action.IAction#run()
+	 */
+	public void run() {
+		if (fStateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT) != fIsFlatLayout) {
+			fStateModel.setBooleanProperty(Values.IS_LAYOUT_FLAT, fIsFlatLayout);
+  			 	
+			fStructuredViewer.getControl().setRedraw(false);
+			fStructuredViewer.refresh();
+			fStructuredViewer.getControl().setRedraw(true);
+		}
+	}
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareContentProvider.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareContentProvider.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareContentProvider.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareContentProvider.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,198 @@
+/***************************************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IWorkspaceRoot;
+
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.jface.viewers.StructuredViewer;
+import org.eclipse.jface.viewers.Viewer;
+
+import org.eclipse.ui.IMemento;
+import org.eclipse.ui.navigator.ICommonContentProvider;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.JavaCore;
+
+import org.eclipse.jdt.ui.PreferenceConstants;
+import org.eclipse.jdt.ui.StandardJavaElementContentProvider;
+
+import org.eclipse.jdt.internal.ui.JavaPlugin;
+import org.eclipse.jdt.internal.ui.packageview.IExtensionStateConstants.Values;
+
+public class PreferenceAwareContentProvider implements ICommonContentProvider {
+	
+	public static final String JDT_EXTENSION_ID = "org.eclipse.jdt.java.navigator"; //$NON-NLS-1$
+
+	private static final Object[] NO_CHILDREN= new Object[0];
+
+	private PackageExplorerContentProvider fDelegateContentProvider;
+	private WorkingSetAwareContentProvider fWorkingSetContentProvider;
+
+	private IMemento fMemento;
+
+	private IExtensionStateModel fStateModel;
+	private final Cache fCache= new Cache();
+
+	private WorkingSetModelManager fManager;
+
+
+	class Cache {
+		public Viewer fViewer;
+		public Object fOldInput;
+		public Object fNewInput;
+
+		public void setValues(Viewer viewer, Object oldInput, Object newInput) {
+			fViewer= viewer;
+			fOldInput= oldInput;
+			fNewInput= newInput;
+		}
+
+	}
+
+	public PreferenceAwareContentProvider() {
+	}
+
+	public void init(IExtensionStateModel aStateModel, IMemento aMemento) {
+		fStateModel= aStateModel;
+		fManager= new WorkingSetModelManager(fStateModel, this);	
+		// expose the manager for the action provider
+		fStateModel.setProperty(WorkingSetModelManager.INSTANCE_KEY, fManager);
+		restoreState(aMemento);
+		fStateModel.addPropertyChangeListener(new IPropertyChangeListener() {
+			public void propertyChange(PropertyChangeEvent event) {
+				if (Values.IS_LAYOUT_FLAT.equals(event.getProperty())) {
+					if (event.getNewValue() != null) {
+						boolean newValue= ((Boolean) event.getNewValue()).booleanValue() ? true : false;
+						fDelegateContentProvider.setIsFlatLayout(newValue);
+					}
+				}
+
+			}
+		});
+		setProviders();
+	}
+
+
+	public void setProviders() {
+		fDelegateContentProvider= createContentProvider();
+		fDelegateContentProvider.inputChanged(fCache.fViewer, fCache.fOldInput, fCache.fNewInput);
+		fDelegateContentProvider.setIsFlatLayout(fStateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT));
+
+	}
+
+	public void dispose() {
+		fDelegateContentProvider.dispose();
+	}
+
+	public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
+		fCache.setValues(viewer, oldInput, newInput);
+		fDelegateContentProvider.inputChanged(viewer, oldInput, findInputElement(newInput));
+		fManager.setViewer((StructuredViewer) viewer);
+	}
+
+	public Object[] getElements(Object inputElement) {
+
+		if (inputElement instanceof IWorkspaceRoot) {
+			Object root= null;
+			if (fManager.showProjects()) 
+				root= JavaCore.create((IWorkspaceRoot) inputElement);
+			else
+				root= fManager.getWorkingSetModel();
+			return fDelegateContentProvider.getElements(root);			
+			
+		} else if (inputElement instanceof IContainer) {
+			IJavaElement element= JavaCore.create((IContainer) inputElement);
+			if (element != null && element.exists())
+				return fDelegateContentProvider.getElements(inputElement);
+			return NO_CHILDREN;
+		}
+
+		return fDelegateContentProvider.getElements(inputElement);
+	}
+
+	public Object[] getChildren(Object parentElement) { 		
+		if(parentElement instanceof IProject)
+			return fDelegateContentProvider.getChildren(JavaCore.create((IProject)parentElement));
+		return fDelegateContentProvider.getChildren(parentElement);
+	}
+	 
+	public Object getParent(Object element) {
+		Object parent = fDelegateContentProvider.getParent(element);
+		if(parent instanceof IJavaProject)
+			return ((IJavaProject)parent).getProject();
+		return parent;
+	}
+
+	public boolean hasChildren(Object element) {
+		return fDelegateContentProvider.hasChildren(element);
+	}
+
+	/**
+	 * This method should only be called inside this class and from test cases.
+	 */
+	public PackageExplorerContentProvider createContentProvider() {
+		IPreferenceStore store= PreferenceConstants.getPreferenceStore();
+		boolean showCUChildren= store.getBoolean(PreferenceConstants.SHOW_CU_CHILDREN);
+		if (fManager.showProjects()) {
+			int options = showCUChildren ? StandardJavaElementContentProvider.SHOW_MEMBERS : 0;			
+			return new PackageExplorerContentProvider(options);
+		}
+		else
+			return new WorkingSetAwareContentProvider(showCUChildren, fManager.getWorkingSetModel());
+	}
+
+	/* package */PackageFragmentProvider getPackageFragmentProvider() {
+		return fDelegateContentProvider.getPackageFragmentProvider();
+	}
+
+	private Object findInputElement(Object newInput) {
+		if (fManager.showWorkingSets()) {
+			return fManager.getWorkingSetModel();
+		} else {
+			if (newInput instanceof IWorkspaceRoot) {
+				return JavaCore.create((IWorkspaceRoot) newInput);
+			} else if (newInput instanceof IContainer) {
+				IJavaElement element= JavaCore.create((IContainer) newInput);
+				if (element != null && element.exists())
+					return element;
+				return newInput;
+			}
+			// 1GERPRT: ITPJUI:ALL - Packages View is empty when shown in Type
+			// Hierarchy Perspective
+			// we can't handle the input
+			// fall back to show the workspace
+			return JavaCore.create(JavaPlugin.getWorkspace().getRoot());
+		}
+	}
+
+	public void restoreState(IMemento aMemento) {
+		fMemento= aMemento;
+		fManager.restoreState(fMemento);
+
+	}
+
+	public void saveState(IMemento aMemento) {
+
+	}
+
+
+
+
+	public PackageExplorerContentProvider getDelegateContentProvider() {
+		return fDelegateContentProvider;
+	}
+
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerActionProvider.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerActionProvider.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerActionProvider.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/PackageExplorerActionProvider.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,91 @@
+/***************************************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.viewers.StructuredViewer;
+
+import org.eclipse.ui.IActionBars;
+import org.eclipse.ui.IMemento;
+import org.eclipse.ui.IViewPart;
+import org.eclipse.ui.navigator.ICommonActionProvider;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+import org.eclipse.ui.navigator.INavigatorContentService;
+import org.eclipse.ui.navigator.internal.actions.CommonActionProvider;
+
+import org.eclipse.jdt.ui.actions.CCPActionGroup;
+
+import org.eclipse.jdt.internal.ui.JavaPlugin;
+import org.eclipse.jdt.internal.ui.packageview.IExtensionStateConstants.Values;
+import org.eclipse.jdt.internal.ui.workingsets.ViewActionGroup;
+
+public class PackageExplorerActionProvider extends CommonActionProvider implements ICommonActionProvider {
+
+	private ViewActionGroup fViewActionGroup;
+	private CommonLayoutActionGroup fLayoutActionGroup;
+	private boolean fHasFilledViewMenu = false;
+	private IExtensionStateModel fStateModel;
+	
+	private CCPActionGroup ccpGroup;
+
+	public boolean fillActionBars(IActionBars theActionBars) {
+		if(!fHasFilledViewMenu) {
+			fViewActionGroup.fillActionBars(theActionBars);
+			fLayoutActionGroup.fillActionBars(theActionBars);
+			fHasFilledViewMenu = true;
+			return true;
+		}
+		return false;
+	}
+
+	public boolean fillContextMenu(IMenuManager aMenu) {
+		 
+		ccpGroup.fillContextMenu(aMenu);
+		return true;
+	}
+
+	public void init(final String anExtensionId, final IViewPart aViewPart, final INavigatorContentService aContentService, final StructuredViewer aStructuredViewer) {
+
+		fStateModel= aContentService.findStateModel(anExtensionId);
+		WorkingSetModelManager workingSetModelManager= (WorkingSetModelManager) fStateModel.getProperty(WorkingSetModelManager.INSTANCE_KEY);
+		fViewActionGroup= new ViewActionGroup(ViewActionGroup.SHOW_PROJECTS, workingSetModelManager, aViewPart.getSite());		 
+
+		fLayoutActionGroup= new CommonLayoutActionGroup(aStructuredViewer, fStateModel);
+		
+		ccpGroup = new CCPActionGroup(aViewPart);
+	}  
+	
+	public void restoreState(IMemento aMemento) { 
+		super.restoreState(aMemento);
+		restoreLayoutState(aMemento);
+	}
+	
+	private void restoreLayoutState(IMemento memento) {
+		boolean isCurrentLayoutFlat= true;
+		Integer state= null;
+		if (memento != null)
+			state= memento.getInteger(MementoFlags.TAG_LAYOUT);
+
+		// If no memento try an restore from preference store
+		if (state == null) {
+			IPreferenceStore store= JavaPlugin.getDefault().getPreferenceStore();
+			state= new Integer(store.getInt(MementoFlags.TAG_LAYOUT));
+		}
+
+		if (state.intValue() == MementoFlags.FLAT_LAYOUT)
+			isCurrentLayoutFlat= true;
+		else if (state.intValue() == MementoFlags.HIERARCHICAL_LAYOUT)
+			isCurrentLayoutFlat= false; 
+		 
+		fStateModel.setBooleanProperty(Values.IS_LAYOUT_FLAT, isCurrentLayoutFlat);
+		fLayoutActionGroup.setFlatLayout(isCurrentLayoutFlat);
+	}
+
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/MementoFlags.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/MementoFlags.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/MementoFlags.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/MementoFlags.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ * IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+public interface MementoFlags {
+
+	int HIERARCHICAL_LAYOUT = 0x1;
+
+	int FLAT_LAYOUT = 0x2;
+
+	// Persistance tags.
+	String TAG_SELECTION = "selection"; //$NON-NLS-1$
+
+	String TAG_EXPANDED = "expanded"; //$NON-NLS-1$
+
+	String TAG_ELEMENT = "element"; //$NON-NLS-1$
+
+	String TAG_PATH = "path"; //$NON-NLS-1$
+
+	String TAG_VERTICAL_POSITION = "verticalPosition"; //$NON-NLS-1$
+
+	String TAG_HORIZONTAL_POSITION = "horizontalPosition"; //$NON-NLS-1$
+
+	String TAG_FILTERS = "filters"; //$NON-NLS-1$
+
+	String TAG_FILTER = "filter"; //$NON-NLS-1$
+
+	String TAG_LAYOUT = "layout"; //$NON-NLS-1$
+
+	String TAG_CURRENT_FRAME = "currentFramge"; //$NON-NLS-1$
+
+	String TAG_ROOT_MODE = "rootMode"; //$NON-NLS-1$
+
+	String SETTING_MEMENTO = "memento"; //$NON-NLS-1$
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/WorkingSetModelManager.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/WorkingSetModelManager.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/WorkingSetModelManager.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/WorkingSetModelManager.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,201 @@
+/***************************************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.core.runtime.ISafeRunnable;
+import org.eclipse.core.runtime.Platform;
+
+import org.eclipse.core.resources.ResourcesPlugin;
+
+import org.eclipse.swt.widgets.Shell;
+
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.jface.viewers.StructuredViewer;
+
+import org.eclipse.ui.IMemento;
+import org.eclipse.ui.IWorkingSet;
+import org.eclipse.ui.IWorkingSetManager;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+
+
+import org.eclipse.jdt.core.JavaCore;
+
+import org.eclipse.jdt.internal.ui.workingsets.ConfigureWorkingSetAction;
+import org.eclipse.jdt.internal.ui.workingsets.ViewActionGroup;
+import org.eclipse.jdt.internal.ui.workingsets.WorkingSetModel;
+
+public class WorkingSetModelManager implements IPropertyChangeListener {
+
+	public static final int SHOW_PROJECTS= ViewActionGroup.SHOW_PROJECTS;
+	public static final int SHOW_WORKING_SETS= ViewActionGroup.SHOW_WORKING_SETS;
+	public static final String MODE_CHANGED= ViewActionGroup.class.getName() + ".mode_changed"; //$NON-NLS-1$
+ 
+	public static final String INSTANCE_KEY= WorkingSetModelManager.class.getName();
+
+	private IExtensionStateModel fStateModel;
+	private WorkingSetModel fWorkingSetModel;
+	private StructuredViewer fViewer; 
+
+	private IMemento fMemento;
+	private PreferenceAwareContentProvider fProvider;
+
+	public WorkingSetModelManager(IExtensionStateModel stateModel, PreferenceAwareContentProvider provider) {
+		fStateModel= stateModel;
+		fProvider = provider;
+	}
+
+	public void setViewer(StructuredViewer viewer) {
+		fViewer= viewer;
+	}
+
+	/**
+	 * 
+	 */
+	private void handleRootModeChanged(int newMode) {
+		rootModeChanged(newMode);
+		Object oldInput= null;
+		Object newInput= null;
+		if (showProjects()) {
+			oldInput= getWorkingSetModel();
+			newInput= JavaCore.create(ResourcesPlugin.getWorkspace().getRoot());
+		} else if (showWorkingSets()) {
+			oldInput= JavaCore.create(ResourcesPlugin.getWorkspace().getRoot());
+			newInput= getWorkingSetModel();
+		}
+		// JDTPORT The Common Navigator does not support Tree Frames yet
+		// if (oldInput != null && newInput != null) {
+		// Frame frame;
+		// for (int i= 0; (frame= fFrameList.getFrame(i)) != null; i++) {
+		// if (frame instanceof TreeFrame) {
+		// TreeFrame treeFrame= (TreeFrame)frame;
+		// if (oldInput.equals(treeFrame.getInput()))
+		// treeFrame.setInput(newInput);
+		// }
+		// }
+		// }
+	}
+
+	public void propertyChange(PropertyChangeEvent event) {
+		if (ViewActionGroup.MODE_CHANGED.equals(event.getProperty())) {
+			handleRootModeChanged(((Integer) event.getNewValue()).intValue());
+		} else {
+			updateTitle(event);
+
+			String property= event.getProperty();
+			if (IWorkingSetManager.CHANGE_WORKING_SET_CONTENT_CHANGE.equals(property)) {
+				refreshViewer();
+			}
+		}
+
+	}
+
+	private void refreshViewer() {
+		if (fViewer != null) {
+			fViewer.getControl().setRedraw(false);
+			fViewer.refresh();
+			fViewer.getControl().setRedraw(true);
+		}
+	}
+
+	/**
+	 * @param event
+	 */
+	private void updateTitle(PropertyChangeEvent event) {
+		IWorkingSet workingSet= (IWorkingSet) event.getNewValue();
+
+		String workingSetName= null;
+		if (workingSet != null)
+			workingSetName= workingSet.getName();
+		// JDTPORT
+		// fPart.setWorkingSetName(workingSetName);
+		// fPart.updateTitle();
+	}
+
+	public boolean showProjects() {
+		return fStateModel.getIntProperty(IExtensionStateConstants.ROOT_MODE) == SHOW_PROJECTS;
+	}
+
+	public boolean showWorkingSets() {
+		return fStateModel.getIntProperty(IExtensionStateConstants.ROOT_MODE) == SHOW_WORKING_SETS;
+	}
+
+	public void rootModeChanged(int newMode) {
+		boolean isRootInputChange = getRootMode() != newMode;
+		setRootMode(newMode);
+		if (showWorkingSets() && fWorkingSetModel == null) {
+			createWorkingSetModel();
+			// JDTPORT
+			// if (fActionSet != null) {
+			// fActionSet.getWorkingSetActionGroup().setWorkingSetModel(fWorkingSetModel);
+			// }
+
+			if (isRootInputChange && fWorkingSetModel.needsConfiguration()) {
+				Shell shell= (fViewer != null) ? fViewer.getControl().getShell() : PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
+
+				ConfigureWorkingSetAction action= new ConfigureWorkingSetAction(shell);
+				action.setWorkingSetModel(fWorkingSetModel);
+				action.run();
+				fWorkingSetModel.configured();
+			}
+		}
+		if(isRootInputChange) {
+			fProvider.setProviders();
+			refreshViewer();
+		}
+	}
+
+
+	public void createWorkingSetModel() {
+		if (fWorkingSetModel == null) {
+			Platform.run(new ISafeRunnable() {
+				public void run() throws Exception {
+					boolean createRestoredModel = fMemento != null && fMemento.getChild(WorkingSetModel.TAG_LOCAL_WORKING_SET_MANAGER) != null;
+					fWorkingSetModel= createRestoredModel ? new WorkingSetModel(fMemento) : new WorkingSetModel();
+					fStateModel.setProperty(IExtensionStateConstants.WORKING_SET_MODEL_KEY, fWorkingSetModel);
+				}
+
+				public void handleException(Throwable exception) {
+					fWorkingSetModel= new WorkingSetModel();
+				}
+			});
+		}
+	}
+
+	public WorkingSetModel getWorkingSetModel() {
+		return fWorkingSetModel;
+	}
+
+	public void restoreState(IMemento aMemento) {
+		fMemento= aMemento;
+		restoreRootMode();
+		if (showWorkingSets()) {
+			createWorkingSetModel();
+		}
+
+	}
+
+	public int getRootMode() {
+		return fStateModel.getIntProperty(IExtensionStateConstants.ROOT_MODE);
+	}
+
+	protected void setRootMode(int aRootMode) {
+		fStateModel.setIntProperty(IExtensionStateConstants.ROOT_MODE, aRootMode);
+	}
+
+	private void restoreRootMode() {
+		int rootMode= SHOW_PROJECTS;
+		if (fMemento != null) {
+			Integer value= fMemento.getInteger(MementoFlags.TAG_ROOT_MODE);
+			rootMode= value != null ? ((value.intValue() == SHOW_PROJECTS) ? SHOW_PROJECTS : SHOW_WORKING_SETS) : SHOW_PROJECTS;
+		}
+		setRootMode(rootMode);
+	}
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareLabelProvider.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareLabelProvider.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareLabelProvider.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/PreferenceAwareLabelProvider.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,189 @@
+/***************************************************************************************************
+ * Copyright (c) 2000, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IResource;
+
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Image;
+
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.jface.viewers.ILabelDecorator;
+import org.eclipse.jface.viewers.ILabelProviderListener;
+import org.eclipse.jface.viewers.ITreeContentProvider;
+
+import org.eclipse.ui.IMemento;
+import org.eclipse.ui.navigator.ICommonLabelProvider;
+import org.eclipse.ui.navigator.IExtensionStateModel;
+
+
+import org.eclipse.jdt.core.IJavaElement;
+
+import org.eclipse.jdt.ui.JavaElementLabels;
+
+import org.eclipse.jdt.internal.ui.packageview.IExtensionStateConstants.Values;
+import org.eclipse.jdt.internal.ui.viewsupport.AppearanceAwareLabelProvider;
+import org.eclipse.jdt.internal.ui.viewsupport.JavaElementImageProvider;
+
+/**
+ * Provides the labels for the Package Explorer.
+ * <p>
+ * It provides labels for the packages in hierarchical layout and in all other cases delegates it to
+ * its super class.
+ * </p>
+ * 
+ * @since 2.1
+ */
+public class PreferenceAwareLabelProvider implements ICommonLabelProvider {
+
+	private final long LABEL_FLAGS= JavaElementLabels.DEFAULT_QUALIFIED | JavaElementLabels.ROOT_POST_QUALIFIED | JavaElementLabels.APPEND_ROOT_PATH | JavaElementLabels.M_PARAMETER_TYPES | JavaElementLabels.M_PARAMETER_NAMES | JavaElementLabels.M_APP_RETURNTYPE | JavaElementLabels.M_EXCEPTIONS | JavaElementLabels.F_APP_TYPE_SIGNATURE | JavaElementLabels.T_TYPE_PARAMETERS;
+
+	private PackageExplorerLabelProvider delegeteLabelProvider;
+
+	private PackageExplorerContentProvider fContentProvider;
+
+	private IExtensionStateModel fStateModel;
+
+	private WorkingSetModelManager fManager;
+
+	public PreferenceAwareLabelProvider() {
+
+	}
+
+	public void init(IExtensionStateModel aStateModel, ITreeContentProvider contentProvider) {
+		fStateModel= aStateModel;
+
+		fManager= (WorkingSetModelManager) fStateModel.getProperty(IExtensionStateConstants.WORKINGSET_MODEL_MANAGER_KEY);
+		
+		fContentProvider= ((PreferenceAwareContentProvider) contentProvider).getDelegateContentProvider();
+		delegeteLabelProvider= createLabelProvider();
+
+		delegeteLabelProvider.setIsFlatLayout(fStateModel.getBooleanProperty(Values.IS_LAYOUT_FLAT));
+		fStateModel.addPropertyChangeListener(new IPropertyChangeListener() {
+			public void propertyChange(PropertyChangeEvent event) {
+				if (Values.IS_LAYOUT_FLAT.equals(event.getProperty())) {
+					if (event.getNewValue() != null) {
+						boolean newValue= ((Boolean) event.getNewValue()).booleanValue() ? true : false;
+						delegeteLabelProvider.setIsFlatLayout(newValue);
+					}
+				}
+
+			}
+		});
+	}
+
+	public String getDescription(Object anElement) {
+		return formatMessage(anElement);
+	}
+
+
+	/* package */boolean showProjects() {
+		return fManager.showProjects();
+	}
+
+	/* package */boolean showWorkingSets() {
+		return fManager.showWorkingSets();
+	}
+
+	private PackageExplorerLabelProvider createLabelProvider() {
+		if (showProjects())
+			return new PackageExplorerLabelProvider(AppearanceAwareLabelProvider.DEFAULT_TEXTFLAGS | JavaElementLabels.P_COMPRESSED, AppearanceAwareLabelProvider.DEFAULT_IMAGEFLAGS | JavaElementImageProvider.SMALL_ICONS, fContentProvider);
+		else
+			return new WorkingSetAwareLabelProvider(AppearanceAwareLabelProvider.DEFAULT_TEXTFLAGS | JavaElementLabels.P_COMPRESSED, AppearanceAwareLabelProvider.DEFAULT_IMAGEFLAGS | JavaElementImageProvider.SMALL_ICONS, fContentProvider);
+	}
+
+	public void dispose() {
+		delegeteLabelProvider.dispose();
+	}
+
+	public void propertyChange(PropertyChangeEvent event) {
+		delegeteLabelProvider.propertyChange(event);
+	}
+
+	public void addLabelDecorator(ILabelDecorator decorator) {
+		delegeteLabelProvider.addLabelDecorator(decorator);
+	}
+
+	public void addListener(ILabelProviderListener listener) {
+		delegeteLabelProvider.addListener(listener);
+	}
+
+	public Color getBackground(Object element) {
+		return delegeteLabelProvider.getBackground(element);
+	}
+
+	public Color getForeground(Object element) {
+		return delegeteLabelProvider.getForeground(element);
+	}
+
+	public Image getImage(Object element) {
+		return delegeteLabelProvider.getImage(element);
+	}
+
+	public boolean isLabelProperty(Object element, String property) {
+		return delegeteLabelProvider.isLabelProperty(element, property);
+	}
+
+	public void removeListener(ILabelProviderListener listener) {
+		delegeteLabelProvider.removeListener(listener);
+	}
+
+	public boolean equals(Object obj) {
+		return delegeteLabelProvider.equals(obj);
+	}
+
+	public int hashCode() {
+		return delegeteLabelProvider.hashCode();
+	}
+
+	public String toString() {
+		return delegeteLabelProvider.toString();
+	}
+
+	public String getText(Object element) {
+		return delegeteLabelProvider.getText(element);
+	}
+
+	public void setIsFlatLayout(boolean state) {
+		delegeteLabelProvider.setIsFlatLayout(state);
+	}
+
+	// Taken from StatusBarUpdater
+
+	protected String formatMessage(Object element) {
+		if (element instanceof IJavaElement) {
+			return formatJavaElementMessage((IJavaElement) element);
+		} else if (element instanceof IResource) {
+			return formatResourceMessage((IResource) element);
+		}
+		return ""; //$NON-NLS-1$
+	}
+
+	private String formatJavaElementMessage(IJavaElement element) {
+		return JavaElementLabels.getElementLabel(element, LABEL_FLAGS);
+	}
+
+	private String formatResourceMessage(IResource element) {
+		IContainer parent= element.getParent();
+		if (parent != null && parent.getType() != IResource.ROOT)
+			return element.getName() + JavaElementLabels.CONCAT_STRING + parent.getFullPath().makeRelative().toString();
+		else
+			return element.getName();
+	}
+
+	public void restoreState(IMemento aMemento) {
+
+	}
+
+	public void saveState(IMemento aMemento) {
+
+	}
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/JavaResourceDuplicationFilter.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/JavaResourceDuplicationFilter.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/JavaResourceDuplicationFilter.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/JavaResourceDuplicationFilter.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ * IBM Corporation - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IResource;
+
+import org.eclipse.ui.navigator.CommonViewer;
+import org.eclipse.ui.navigator.INavigatorExtensionFilter;
+import org.eclipse.ui.navigator.internal.filters.NavigatorExtensionFilter;
+
+import org.eclipse.jdt.core.JavaCore;
+
+public class JavaResourceDuplicationFilter extends NavigatorExtensionFilter implements INavigatorExtensionFilter {
+ 
+	public boolean select(CommonViewer aViewer, Object aParentElement,
+			Object anElement) {
+		if (anElement instanceof IFile || anElement instanceof IFolder) {
+			IResource res = (IResource) anElement;
+			return "class".equals(res.getFileExtension()) || !(JavaCore.create(res) != null); //$NON-NLS-1$
+		}
+		return true;
+	}
+
+}
Index: ui/org/eclipse/jdt/internal/ui/packageview/IExtensionStateConstants.java
===================================================================
RCS file: ui/org/eclipse/jdt/internal/ui/packageview/IExtensionStateConstants.java
diff -N ui/org/eclipse/jdt/internal/ui/packageview/IExtensionStateConstants.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ui/org/eclipse/jdt/internal/ui/packageview/IExtensionStateConstants.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,28 @@
+/***************************************************************************************************
+ * Copyright (c) 2003, 2004 IBM Corporation and others. All rights reserved. This program and the
+ * accompanying materials are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ **************************************************************************************************/
+package org.eclipse.jdt.internal.ui.packageview;
+
+import org.eclipse.jdt.internal.ui.workingsets.ViewActionGroup;
+
+public interface IExtensionStateConstants {
+
+	String WORKING_SET_MODEL_KEY= "workingSetModel"; //$NON-NLS-1$
+	String ROOT_MODE= "rootMode"; //$NON-NLS-1$
+	String WORKINGSET_MODEL_MANAGER_KEY = WorkingSetModelManager.INSTANCE_KEY;
+
+	interface Values {
+
+		String IS_LAYOUT_FLAT= "isLayoutFlat"; //$NON-NLS-1$
+
+		int SHOW_PROJECTS= ViewActionGroup.SHOW_PROJECTS;
+		int SHOW_WORKING_SETS= ViewActionGroup.SHOW_WORKING_SETS;
+
+	}
+
+}
