/******************************************************************************* * Copyright (c) 2006 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *     IBM Corporation - initial API and implementation ******************************************************************************/package org.eclipse.ui.tests.menus;import java.util.Iterator;import java.util.List;import org.eclipse.jface.menus.ILayoutNode;import org.eclipse.jface.menus.SBar;import org.eclipse.jface.menus.SLocation;import org.eclipse.jface.menus.SMenu;import org.eclipse.jface.menus.SMenuLayout;import org.eclipse.jface.menus.SMenuManager;import org.eclipse.jface.menus.SOrder;import org.eclipse.ui.tests.harness.util.UITestCase;/** * <p> * Tests the ordering constraints for menu contributions. This checks to make * sure that the various ordering constraints specified by * {@link org.eclipse.jface.menus.SOrder} are understood. * </p> *  * @since 3.2 */public final class OrderingTest extends UITestCase {	/**	 * The menu manager to use for each test. This is created and destroyed on	 * every setup and tear-down.	 */	private SMenuManager manager;	/**	 * Constructs a new instance of <code>OrderingTest</code> with the name of	 * the test.	 * 	 * @param name	 *            The name of the test; may be <code>null</code>.	 */	public OrderingTest(final String name) {		super(name);	}	protected final void doSetUp() throws Exception {		super.doSetUp();		// Create a menu manager.		manager = new SMenuManager();		// Register three menus with no ordering constraints: A, B, C		final SLocation location = new SLocation(new SBar());		SMenu menu;		menu = manager.getMenu("A");		menu.define("A", location);		menu = manager.getMenu("B");		menu.define("B", location);		menu = manager.getMenu("C");		menu.define("C", location);	}	protected void doTearDown() throws Exception {		super.doTearDown();		manager = null;	}	/**	 * Tests whether the after position works in the simple case where linear	 * sorting is used.	 */	public final void testAfterA() {		final SMenu menu = manager.getMenu("afterA");		final SLocation location = new SLocation(new SBar(), new SOrder(				SOrder.POSITION_AFTER, "A"));		menu.define("afterA", location);		final SMenuLayout layout = manager.getLayout();		final ILayoutNode node = layout.getBar(SBar.TYPE_MENU);		final List children = node.getChildrenSorted();		final Iterator childItr = children.iterator();		while (childItr.hasNext()) {			final ILayoutNode child = (ILayoutNode) childItr.next();			if ("A".equals(child.getMenuElement().getId())) {				final ILayoutNode next = (ILayoutNode) childItr.next();				assertEquals("The after constraint failed", "afterA", next						.getMenuElement().getId());				return;			}		}		fail("Could not find contribution");	}	/**	 * Tests whether the after position works after a before position in the	 * simple case where linear sorting is used.	 */	public final void testAfterBeforeA() {		SMenu menu;		SLocation location;		menu = manager.getMenu("beforeA");		location = new SLocation(new SBar(), new SOrder(SOrder.POSITION_BEFORE,				"A"));		menu.define("beforeA", location);		menu = manager.getMenu("afterBeforeA");		location = new SLocation(new SBar(), new SOrder(SOrder.POSITION_AFTER,				"beforeA"));		menu.define("afterBeforeA", location);		final SMenuLayout layout = manager.getLayout();		final ILayoutNode node = layout.getBar(SBar.TYPE_MENU);		final List children = node.getChildrenSorted();		final Iterator childItr = children.iterator();		while (childItr.hasNext()) {			final ILayoutNode child = (ILayoutNode) childItr.next();			if ("beforeA".equals(child.getMenuElement().getId())) {				final ILayoutNode next = (ILayoutNode) childItr.next();				assertEquals("The nested before/after constraint failed",						"afterBeforeA", next.getMenuElement().getId());				return;			}		}		fail("Could not find contribution");	}	/**	 * Tests whether the before position works in the simple case where linear	 * sorting is used.	 */	public final void testBeforeA() {		final SMenu menu = manager.getMenu("beforeA");		final SLocation location = new SLocation(new SBar(), new SOrder(				SOrder.POSITION_BEFORE, "A"));		menu.define("beforeA", location);		final SMenuLayout layout = manager.getLayout();		final ILayoutNode node = layout.getBar(SBar.TYPE_MENU);		final List children = node.getChildrenSorted();		final Iterator childItr = children.iterator();		while (childItr.hasNext()) {			final ILayoutNode child = (ILayoutNode) childItr.next();			if (child.getMenuElement() == menu) {				final ILayoutNode next = (ILayoutNode) childItr.next();				assertEquals("The before constraint failed", "A", next						.getMenuElement().getId());				return;			}		}		fail("Could not find contribution");	}	/**	 * Tests whether the before position works relative to an after position in	 * the simple case where linear sorting is used.	 */	public final void testBeforeAfterA() {		SMenu menu;		SLocation location;		menu = manager.getMenu("afterA");		location = new SLocation(new SBar(), new SOrder(SOrder.POSITION_AFTER,				"A"));		menu.define("afterA", location);		menu = manager.getMenu("beforeAfterA");		location = new SLocation(new SBar(), new SOrder(SOrder.POSITION_BEFORE,				"afterA"));		menu.define("beforeAfterA", location);		final SMenuLayout layout = manager.getLayout();		final ILayoutNode node = layout.getBar(SBar.TYPE_MENU);		final List children = node.getChildrenSorted();		final Iterator childItr = children.iterator();		while (childItr.hasNext()) {			final ILayoutNode child = (ILayoutNode) childItr.next();			if (child.getMenuElement() == menu) {				final ILayoutNode next = (ILayoutNode) childItr.next();				assertEquals("The nested before/after constraint failed",						"afterA", next.getMenuElement().getId());				return;			}		}		fail("Could not find contribution");	}	/**	 * Tests whether the end position works in the simple case where linear	 * sorting is used.	 */	public final void testEnd() {		final SMenu menu = manager.getMenu("end");		final SLocation location = new SLocation(new SBar(), new SOrder(				SOrder.POSITION_END));		menu.define("end", location);		final SMenuLayout layout = manager.getLayout();		final ILayoutNode node = layout.getBar(SBar.TYPE_MENU);		final List children = node.getChildrenSorted();		final ILayoutNode lastNode = (ILayoutNode) children				.get(children.size() - 1);		assertEquals("The end ordering constraint failed", menu, lastNode				.getMenuElement());	}	/**	 * Tests whether the start position works in the simple case where linear	 * sorting is used.	 */	public final void testStart() {		final SMenu menu = manager.getMenu("start");		final SLocation location = new SLocation(new SBar(), new SOrder(				SOrder.POSITION_START));		menu.define("start", location);		final SMenuLayout layout = manager.getLayout();		final ILayoutNode node = layout.getBar(SBar.TYPE_MENU);		final List children = node.getChildrenSorted();		final ILayoutNode firstNode = (ILayoutNode) children.get(0);		assertEquals("The start ordering constraint failed", menu, firstNode				.getMenuElement());	}}